import { describe, expect, test } from "vitest";
import type { TieredCommits, TieredStats } from "@/types";
import { createCommitEntry, createOutputOptions } from "@/utils/__tests__/fixtures";
import {
  generateMarkdownOutput,
  generateMarkdownOutputWithBranches,
} from "../markdown";

describe("generateMarkdownOutput", () => {
  const mockCommits = {
    Features: [
      createCommitEntry({
        hash: "abc123def456",
        message: "feat: new feature",
        date: "2024-03-15T10:00:00Z",
        repoName: "repo1",
      }),
      createCommitEntry({
        hash: "ghi789jkl012",
        message: "feat: another feature",
        date: "2024-03-16T10:00:00Z",
        repoName: "repo2",
      }),
    ],
    Fixes: [
      createCommitEntry({
        hash: "mno345pqr678",
        message: "fix: bug fix",
        date: "2024-03-17T10:00:00Z",
        repoName: "repo1",
      }),
    ],
  };

  test("generates output with category grouping", () => {
    const result = generateMarkdownOutput(
      mockCommits,
      createOutputOptions({
        format: "markdown",
        groupBy: "category",
        color: "auto",
      }),
    );

    expect(result).toContain("# Dev Log:");
    expect(result).toContain("## Features");
    expect(result).toContain("### repo1");
    expect(result).toContain("### repo2");
    expect(result).toContain("## Fixes");
    expect(result).toContain("[abc123d] feat: new feature");
    expect(result).toContain("_Generated by devrec_");
  });

  test("generates output with repo grouping", () => {
    const result = generateMarkdownOutput(
      mockCommits,
      createOutputOptions({
        format: "markdown",
        groupBy: "repo",
        color: "auto",
      }),
    );

    expect(result).toContain("# Dev Log:");
    expect(result).toContain("## repo1");
    expect(result).toContain("## repo2");
    expect(result).toContain("### Features");
    expect(result).toContain("### Fixes");
    expect(result).toContain("_Generated by devrec_");
  });

  test("includes summary when showSummary is true", () => {
    const result = generateMarkdownOutput(
      mockCommits,
      createOutputOptions({
        format: "markdown",
        showSummary: true,
        color: "auto",
      }),
      { since: "Mon Mar 11 2024", until: "Fri Mar 15 2024" },
    );

    expect(result).toContain("## Summary");
    expect(result).toContain("- **Total Commits**: 3");
    expect(result).toContain("- **Repositories**: repo1, repo2");
    expect(result).toContain(
      "- **Date Range**: Mon Mar 11 2024 to Fri Mar 15 2024",
    );
  });

  test("omits summary when showSummary is false", () => {
    const result = generateMarkdownOutput(
      mockCommits,
      createOutputOptions({ format: "markdown", color: "auto" }),
    );

    expect(result).not.toContain("## Summary");
    expect(result).not.toContain("Total Commits");
  });

  test("handles empty commits", () => {
    const result = generateMarkdownOutput(
      {},
      createOutputOptions({ format: "markdown", color: "auto" }),
    );

    expect(result).toContain("# Dev Log:");
    expect(result).toContain("_Generated by devrec_");
  });

  test("does not produce excessive blank lines", () => {
    const result = generateMarkdownOutput(
      mockCommits,
      createOutputOptions({ format: "markdown", color: "auto" }),
    );

    expect(result).not.toMatch(/\n{4,}/);
  });

  test("includes year in date formatting", () => {
    const result = generateMarkdownOutput(
      mockCommits,
      createOutputOptions({ format: "markdown", color: "auto" }),
    );

    expect(result).toMatch(/\d{4}/);
  });
});

describe("special markdown character handling", () => {
  test("handles commit messages with asterisks", () => {
    const commitsWithAsterisks = {
      feature: [
        createCommitEntry({
          hash: "abc123",
          message: "feat: add *emphasis* support",
          date: "2024-01-15T10:00:00.000Z",
          repoName: "repo1",
        }),
      ],
    };

    const result = generateMarkdownOutput(
      commitsWithAsterisks,
      createOutputOptions({ format: "markdown", color: "auto" }),
    );

    expect(result).toContain("feat: add *emphasis* support");
    expect(result).toContain("## feature");
    expect(result).toContain("### repo1");
  });

  test("handles commit messages with underscores", () => {
    const commitsWithUnderscores = {
      fix: [
        createCommitEntry({
          hash: "def456",
          message: "fix: update _private_ variable",
          date: "2024-01-15T10:00:00.000Z",
          repoName: "repo1",
        }),
      ],
    };

    const result = generateMarkdownOutput(
      commitsWithUnderscores,
      createOutputOptions({ format: "markdown", color: "auto" }),
    );

    expect(result).toContain("fix: update _private_ variable");
  });

  test("handles commit messages with brackets", () => {
    const commitsWithBrackets = {
      feature: [
        createCommitEntry({
          hash: "ghi789",
          message: "feat: add [optional] parameter",
          date: "2024-01-15T10:00:00.000Z",
          repoName: "repo1",
        }),
      ],
    };

    const result = generateMarkdownOutput(
      commitsWithBrackets,
      createOutputOptions({ format: "markdown", color: "auto" }),
    );

    expect(result).toContain("feat: add [optional] parameter");
  });

  test("handles commit messages with hash symbols", () => {
    const commitsWithHash = {
      fix: [
        createCommitEntry({
          hash: "jkl012",
          message: "fix: prevent # comment conflicts",
          date: "2024-01-15T10:00:00.000Z",
          repoName: "repo1",
        }),
      ],
    };

    const result = generateMarkdownOutput(
      commitsWithHash,
      createOutputOptions({ format: "markdown", color: "auto" }),
    );

    expect(result).toContain("fix: prevent # comment conflicts");
    const headerCount = (result.match(/^#{1,3}\s/gm) ?? []).length;
    expect(headerCount).toBeLessThan(10);
  });

  test("handles commit messages with backticks", () => {
    const commitsWithBackticks = {
      feature: [
        createCommitEntry({
          hash: "mno345",
          message: "feat: add `inline code` support",
          date: "2024-01-15T10:00:00.000Z",
          repoName: "repo1",
        }),
      ],
    };

    const result = generateMarkdownOutput(
      commitsWithBackticks,
      createOutputOptions({ format: "markdown", color: "auto" }),
    );

    expect(result).toContain("feat: add `inline code` support");
  });

  test("handles commit messages with multiple special characters", () => {
    const complexCommits = {
      feature: [
        createCommitEntry({
          hash: "pqr678",
          message: "feat: support **bold**, _italic_, and [links]",
          date: "2024-01-15T10:00:00.000Z",
          repoName: "repo1",
        }),
      ],
    };

    const result = generateMarkdownOutput(
      complexCommits,
      createOutputOptions({ format: "markdown", color: "auto" }),
    );

    expect(result).toContain("feat: support **bold**, _italic_, and [links]");
  });
});

describe("generateMarkdownOutputWithBranches", () => {
  const createTiered = (overrides?: Partial<TieredCommits>): TieredCommits => ({
    keyContributions: { merged: {}, unmerged: {} },
    otherWork: { merged: {}, unmerged: {} },
    ...overrides,
  });

  const createStats = (overrides?: Partial<TieredStats>): TieredStats => ({
    totalCommits: 0,
    mergedCommits: 0,
    unmergedCommits: 0,
    repos: new Set<string>(),
    keyContributionCount: 0,
    ...overrides,
  });

  test("shows Key Contributions and Other Work when both tiers present", () => {
    const tiered = createTiered({
      keyContributions: {
        merged: {
          Feature: [
            createCommitEntry({
              hash: "abc123",
              message: "feat: security fix",
              repoName: "repo1",
            }),
          ],
        },
        unmerged: {},
      },
      otherWork: {
        merged: {
          Chore: [
            createCommitEntry({
              hash: "def456",
              message: "chore: update deps",
              repoName: "repo1",
            }),
          ],
        },
        unmerged: {},
      },
    });
    const stats = createStats({
      totalCommits: 2,
      mergedCommits: 2,
      repos: new Set(["repo1"]),
      keyContributionCount: 1,
    });

    const result = generateMarkdownOutputWithBranches(
      tiered,
      stats,
      createOutputOptions({ format: "markdown" }),
    );

    expect(result).toContain("## Key Contributions");
    expect(result).toContain("feat: security fix");
    expect(result).toContain("## Other Work");
    expect(result).toContain("chore: update deps");
    expect(result).toContain("_Generated by devrec_");
  });

  test("skips tier headers when only other work exists", () => {
    const tiered = createTiered({
      otherWork: {
        merged: {
          Feature: [
            createCommitEntry({
              hash: "abc123",
              message: "feat: feature",
              repoName: "repo1",
            }),
          ],
        },
        unmerged: {},
      },
    });
    const stats = createStats({
      totalCommits: 1,
      mergedCommits: 1,
      repos: new Set(["repo1"]),
    });

    const result = generateMarkdownOutputWithBranches(
      tiered,
      stats,
      createOutputOptions({ format: "markdown" }),
    );

    expect(result).not.toContain("## Key Contributions");
    expect(result).not.toContain("## Other Work");
    expect(result).toContain("feat: feature");
  });

  test("shows only Key Contributions header when no other work", () => {
    const tiered = createTiered({
      keyContributions: {
        merged: {
          Feature: [
            createCommitEntry({
              hash: "abc123",
              message: "feat: security patch",
              repoName: "repo1",
            }),
          ],
        },
        unmerged: {},
      },
    });
    const stats = createStats({
      totalCommits: 1,
      mergedCommits: 1,
      repos: new Set(["repo1"]),
      keyContributionCount: 1,
    });

    const result = generateMarkdownOutputWithBranches(
      tiered,
      stats,
      createOutputOptions({ format: "markdown" }),
    );

    expect(result).toContain("## Key Contributions");
    expect(result).not.toContain("## Other Work");
  });

  test("includes key contribution count in summary", () => {
    const tiered = createTiered();
    const stats = createStats({
      totalCommits: 5,
      mergedCommits: 3,
      unmergedCommits: 2,
      repos: new Set(["repo1"]),
      keyContributionCount: 2,
    });

    const result = generateMarkdownOutputWithBranches(
      tiered,
      stats,
      createOutputOptions({ format: "markdown", showSummary: true }),
      { since: "2024-03-11", until: "2024-03-15" },
    );

    expect(result).toContain("## Summary");
    expect(result).toContain("**Key Contributions**: 2");
    expect(result).toContain("**Total Commits**: 5");
  });

  test("omits key contribution count from summary when zero", () => {
    const tiered = createTiered();
    const stats = createStats({ totalCommits: 1, repos: new Set(["repo1"]) });

    const result = generateMarkdownOutputWithBranches(
      tiered,
      stats,
      createOutputOptions({ format: "markdown", showSummary: true }),
    );

    expect(result).not.toContain("Key Contributions");
  });

  test("shows checkmark for merged commits", () => {
    const tiered = createTiered({
      otherWork: {
        merged: {
          Feature: [
            createCommitEntry({
              hash: "abc123",
              message: "feat: merged",
              repoName: "repo1",
            }),
          ],
        },
        unmerged: {
          Feature: [
            createCommitEntry({
              hash: "def456",
              message: "feat: unmerged",
              repoName: "repo1",
              branch: "feat/test",
            }),
          ],
        },
      },
    });
    const stats = createStats({
      totalCommits: 2,
      mergedCommits: 1,
      unmergedCommits: 1,
      repos: new Set(["repo1"]),
    });

    const result = generateMarkdownOutputWithBranches(
      tiered,
      stats,
      createOutputOptions({ format: "markdown" }),
    );

    expect(result).toContain("\u2713 [abc123]");
    expect(result).toContain("`[feat/test]`");
  });

  test("handles empty tiered commits", () => {
    const tiered = createTiered();
    const stats = createStats();

    const result = generateMarkdownOutputWithBranches(
      tiered,
      stats,
      createOutputOptions({ format: "markdown" }),
    );

    expect(result).toContain("# Dev Log:");
    expect(result).toContain("_Generated by devrec_");
    expect(result).not.toContain("## Key Contributions");
    expect(result).not.toContain("## Other Work");
  });
});

describe("unicode and special characters", () => {
  test("handles emoji in commit messages", () => {
    const commitsWithEmoji = {
      feature: [
        createCommitEntry({
          hash: "stu901",
          message: "feat: add ðŸŽ‰ celebration feature",
          date: "2024-01-15T10:00:00.000Z",
          repoName: "repo1",
        }),
      ],
    };

    const result = generateMarkdownOutput(
      commitsWithEmoji,
      createOutputOptions({ format: "markdown", color: "auto" }),
    );

    expect(result).toContain("ðŸŽ‰");
    expect(result).toContain("celebration feature");
  });

  test("handles very long commit messages", () => {
    const longMessage = "feat: " + "a".repeat(500);
    const commitsWithLongMessage = {
      feature: [
        createCommitEntry({
          hash: "vwx234",
          message: longMessage,
          date: "2024-01-15T10:00:00.000Z",
          repoName: "repo1",
        }),
      ],
    };

    const result = generateMarkdownOutput(
      commitsWithLongMessage,
      createOutputOptions({ format: "markdown", color: "auto" }),
    );

    expect(result).toContain(longMessage);
  });

  test("handles RTL text in commit messages", () => {
    const commitsWithRTL = {
      feature: [
        createCommitEntry({
          hash: "yza567",
          message: "feat: add support for Ù…Ø±Ø­Ø¨Ø§ (hello in Arabic)",
          date: "2024-01-15T10:00:00.000Z",
          repoName: "repo1",
        }),
      ],
    };

    const result = generateMarkdownOutput(
      commitsWithRTL,
      createOutputOptions({ format: "markdown", color: "auto" }),
    );

    expect(result).toContain("Ù…Ø±Ø­Ø¨Ø§");
  });
});
